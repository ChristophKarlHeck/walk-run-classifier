package com.example.walkrunclassifier.testutils

import android.content.Context
import android.util.Log
import com.example.walkrunclassifier.sensors.AccelerometerData
import com.example.walkrunclassifier.sensors.AccelerometerDataSource
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.IOException

/**
 * A [AccelerometerDataSource] that reads accelerometer data from a CSV file stored in
 * the androidTest assets directory.
 *
 * Each line in the CSV file is expected to contain three comma-separated float values
 * representing the x, y, and z axes of the accelerometer, in that order.
 * Example line: "0.123,9.81,-0.456"
 *
 * Timestamps are generated by this data source as the CSV files do not contain them.
 *
 * @param testContext The context used to access assets (typically from an instrumented test).
 * @param csvFileName The name of the CSV file in the "assets" directory ("walking.csv").
 * @param emissionDelayMillis The delay in milliseconds between emitting each data point.
 *                            This simulates a sensor sampling interval. Default is ~26Hz.
 * @param skipHeaderLine Set to true if the CSV file has a header line that should be skipped.
 */
class CsvAccelerometerDataSource(
    private val testContext: Context,
    private val csvFileName: String,
    private val emissionDelayMillis: Long = (1_000_000f / 26).toLong(), // Approx 26Hz
    private val skipHeaderLine: Boolean = false // Set to true if your CSV has a header
) : AccelerometerDataSource {

    companion object {
        private const val TAG = "CsvDataSource"
    }

    override fun getAccelerometerData(): Flow<AccelerometerData> = callbackFlow {
        Log.d(TAG, "Initializing CSV data source for: $csvFileName")

        val job = launch(Dispatchers.IO) { // Perform file reading on IO dispatcher
            try {
                // Accessing assets from main/assets
                testContext.assets.open(csvFileName).use { inputStream ->
                    BufferedReader(InputStreamReader(inputStream)).use { reader ->
                        if (skipHeaderLine) {
                            val header = reader.readLine()
                            Log.d(TAG, "Skipped header line for $csvFileName: $header")
                        }

                        var line: String? = reader.readLine()
                        var lineNumber = if (skipHeaderLine) 2 else 1

                        while (isActive && line != null) {
                            val currentLine = line

                            // Trim the whole line and then split. Also trim individual parts.
                            val parts = currentLine.trim().split(',').map { it.trim() }

                            if (parts.size >= 3) {
                                val x = parts[0].toFloatOrNull()
                                val y = parts[1].toFloatOrNull()
                                val z = parts[2].toFloatOrNull()
                                val timestamp = System.nanoTime() // Generate timestamp

                                if (x != null && y != null && z != null) {
                                    val data = AccelerometerData(timestamp, x, y, z)
                                    // isSuccess can be checked for backpressure handling
                                    trySend(data).isSuccess
                                } else {
                                    Log.w(TAG, "Skipping malformed line in " +
                                            "$csvFileName (line $lineNumber, null " +
                                            "after parsing): '$currentLine'")
                                }
                            } else {
                                Log.w(TAG, "Skipping line in " +
                                        "$csvFileName (line $lineNumber, not enough parts, " +
                                        "expected 3, got ${parts.size}): '$currentLine'")
                            }

                            if (emissionDelayMillis > 0) {
                                delay(emissionDelayMillis)
                            }
                            line = reader.readLine()
                            lineNumber++
                        }
                        Log.i(TAG, "Finished reading all lines from $csvFileName. " +
                                "Total lines processed: ${lineNumber -1}.")
                    }
                }
            } catch (e: IOException) {
                Log.e(TAG, "Error reading CSV file $csvFileName", e)
                close(e) // Close the flow with an error if reading fails
            } catch (e: Exception) {
                Log.e(TAG, "An unexpected error occurred while processing $csvFileName", e)
                close(e)
            } finally {
                if (!isClosedForSend) {
                    Log.d(TAG, "Closing flow for $csvFileName as reading " +
                            "is complete or an error occurred.")
                    close() // Ensure the flow completes
                }
            }
        }

        awaitClose {
            Log.d(TAG, "CSV Flow for $csvFileName is being closed. Cancelling associated job.")
            job.cancel()
        }
    }
}
